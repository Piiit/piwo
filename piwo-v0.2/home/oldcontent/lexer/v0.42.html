      <div id='imwiki'>
<div class="section_border">
Sie sind hier: <a href='?mode=cleared&id=index'>Home</a> &raquo; <a href='?mode=cleared&id=reise'>Reise</a> &raquo; Fotoalbum<span class="less_significant"> | <a href="?id=dokumentation:todos">Todos anzeigen</a></span></div>
Link: <a target="_blank" href="http://localhost/projekte/home/lib/tests/lexer42.php">Lexer v0.42</a>  <br />
Link: <a target="_blank" href="http://localhost/projekte/home/lib/tests/lexer42cleanup.php">Lexer v0.42B</a>  <br />
Link: <a target="_blank" href="http://localhost/projekte/home/lib/tests/lexer42c.php">Lexer v0.42C</a> <br />
Link: <a target="_blank" href="http://localhost/projekte/home/lib/tests/lexertests/">Lexer v0.42D - Testumgebung</a><h1 id="header_"> Todo/Changelog </h1><h2 id="header_"> v0.42B </h2>        <ul>
        </ul><ul><li>
:i: <span class="code">addAbstractNode</span> wurde verworfen... wird sp&auml;ter komplett neu entwickelt!        </li>
        <li>
:ok: Cache f&uuml;r Regexp, damit <span class="code">getPatternString</span> nur einmal f&uuml;r jeden Modus die Regexp bauen muss.        </li>
        </ul>
<h2 id="header_"> v0.42C </h2>        <ul>
        </ul><ul><li>
:ok: WORD-Pattern einf&uuml;hren        </li>
        <li>
:ok: Level-Berechnung f&uuml;r jedes Token: Performance -&gt; nur einmal berechnen!        </li>
        <li>
:ok: Debug: Tests in v0.42G        </li>
        <ul><li>
:ok: Ausgabe &uuml;ber <a href="?id=reise:dom-funktionen&mode=editpage" class="pw_wiki_link_na">DOM-Funktionen</a>  (Diese Funktionen sollten auch dem Parser zur Verf&uuml;gung stehen -&gt; <span class="code">public</span>)        </li>
        <li>
:ok: Aufwendige Debugfunktionen nur starten, wenn gefordert (Parameter im constructor) &lt;= PERFORMANCE!         </li>
        <li>
:ok: jeden Status f&uuml;r jeden Zyklus speichern        </li>
        <li>
:ok: PERFORMANCE: Nur Textposition speichern... Speicherbedarf reduzieren!        </li>
        <li>
:ok: Funktionen f&uuml;r Ausgabe der Debuginformationen (<span class="code">getBeforeMatch</span>, <span class="code">getAfterMatch</span>, <span class="code">showEntities</span>) <br /> Rest wird &uuml;ber <span class="code">getDebugInfo</span> ausgegeben (<span class="code">array</span>)        </li></ul>
        <li>
:ok: <a href="?id=reise:asttree&mode=editpage" class="pw_wiki_link_na">Abstract Syntax Tree (AST)</a> wie in ANTLR ausgeben        </li>
        </ul>
<h2 id="header_"> v0.42D </h2>        <ul>
        </ul><ul><li>
:ok: <a href="?id=reise:abstractnode&mode=editpage" class="pw_wiki_link_na">Abstrakte Knoten</a>: Bsp. <span class="code">tablerow</span>-Knoten sollten im Elternknoten <span class="code">table</span> zusammengefasst werden.        </li>
        <li>
Bessere <span class="code">addLog</span> Funktionen (<span class="code">array</span> und <span class="code">class</span>)        </li>
        <li>
Verschiedene Testprogramme mit Auswahlliste, Ladefunktion etc. um Bugs herauszufinden        </li>
        <li>
Log und Debug als Objektklasse verbinden und in separater Datei ablegen        </li>
        <li>
AST Schleife auslagern        </li>
        <li>
Testprogramme in separaten Dateien ablegen (DOM-Tests, Debug/Log-Tests, ...)        </li>
        <li>
:?: DOM-Funktionen mit internen Node-Zeiger im Lexer (Knoten sollten Objekte mit Zeigerfunktionen sein, abgeleitet von <span class="code">pwLexer</span>)        </li>
        </ul>
<h2 id="header_"> v0.42E </h2>        <ul>
        </ul><ul><li>
Doppelt vergebene Pattern abfangen und ???        </li>
        <li>
Leeren Exitpattern -&gt; daf&uuml;r array mit Modes, die den aktuellen Status beenden, wenn neuer gestartet wird... <br /> oder leer, wenn jeder neue Status den aktuellen beendet.        </li>
        </ul>
<h2 id="header_"> v0.42F </h2>        <ul>
        </ul><ul><li>
Parameter (Flag): <span class="code">NO_SHIFT</span>, damit ein Muster erkannt wird, der Textzeiger aber stehen bleibt. Bsp.: <span class="code">tablerow</span> (Autom. Umwandlung in einen lookahead)        </li>
        <li>
Parameter (Flag): <span class="code">NOT_EMPTY</span> bedeutet der Textknoten innerhalb eines Tokens darf nicht leer sein.        </li>
        <li>
Parameter (Flag): <span class="code">IGNORE_EMPTY</span> Leere Tokens werden ignoriert. Bsp.: <span class="code">== ==</span> wird zwar als <span class="code">header</span> erkannt aber nicht in den AST aufgenommen.        </li>
        </ul>
<h2 id="header_"> v0.42G </h2>        <ul>
        </ul><ul><li>
FEATURE: AST als dynamische Liste (Javascript) ausgeben (wie Filemanager)        </li>
        <li>
Code aufr&auml;umen        </li>
        <li>
Bugfixes        </li>
        <li>
Tests        </li>
        </ul>
<h1 id="header_"> getPatternString: modes </h1><pre><div>
 /**
  * Gibt den regul&auml;ren Ausdruck f&uuml;r den aktuellen Status zur&uuml;ck.
   * Erlaubte line- und section_start pattern inkl. des section_end patterns des
   * aktuellen Status' wird zur&uuml;ckgeliefert.
   *
   * @param   string          $statusname    Name des aktuellen Status (Bsp. quoted string), default = #DOCUMENT
   * @param   boolean         $keysensitive  'i'-Parameter f&uuml;r die regex, default = false
   * @return  string/boolean  regexp-string oder false bei einem Fehler
   */

  public function getPatternString($statusname = &quot;#DOCUMENT&quot;, $keysensitive = false)

</div></pre>
Jeder Modus darf in einem bestimmten Kontext vorkommen. Siehe <a href="#" class="pw_wiki_link_na">addsectionpattern</a>.

Falls eine neue Sektion aufgenommen wird, kann man festlegen worin sie vorkommen darf.
Der aktuelle <span class="code">patternstring</span> enth&auml;lt immer nur die erlaubten pattern und zwar in folgender Reihenfolge:        <ol>
        </ol><ol><li>
Alle erlaubten <span class="code">enter</span>-pattern        </li>
        <li>
und einen <span class="code">exit</span>-pattern f&uuml;r den aktuellen Modus        </li>
        </ol>
<h1 id="header_"> addSectionPattern </h1>
Paramterliste:<div class="tablediv"><table><tr><th> Paramtername </th><th> Datentyp </th><th> Erkl&auml;rung </th><th> Beispiel </th><th colspan="3"> Syntaxbeispiele </th></tr><tr><td> <span class="code">name</span> </td></td><td> string </td></td><td> Statusname </td></td><td> header </td></td><td colspan="2"> <span class="code">= &Uuml;berschrift =</span></td></td></tr><tr><td> <span class="code">entrypattern</span> </td></td><td> string(regexp) </td></td><td> wenn dieses Token gefunden wird, wechselt der Lexer in ein neuen Status <span class="code">name</span> </td></td><td> header </td></td><td colspan="2"> <span class="code">\n\s*={1,5}</span></td></td></tr><tr><td> <span class="code">exitpattern</span> </td></td><td> string(regexp) </td></td><td> wenn dieses Token gefunden wird, verl&auml;sst der Lexer den aktuellen Status wieder </td></td><td> header </td></td><td colspan="2"> <span class="code">={1,5}</span></td></td></tr><tr><td> <span class="code">modes</span> </td></td><td> array </td></td><td> Alle Kontextnamen, in denen <span class="code">name</span> erlaubt ist. <br /> <span class="code">header</span> darf nur in #DOCUMENT und section vorkommen, wird in zB. Listen ignoriert </td></td><td colspan="3"> <span class="code">array(&quot;#DOCUMENT&quot;, &quot;section&quot;)</span> </td></td></td></tr><tr><td> <span class="code">type</span> </td></td><td> string <br /> :fixme: </td></td><td colspan="4"> Alle Typen: <span class="code">TYPE_SECTION</span>; <span class="code">TYPE_LINE</span>; <span class="code">TYPE_WORD</span> <br /> (sollte in Zukunft auf versch. Flags/Parameter erweitert werden <br /> Bsp. <span class="code">EMPTY</span>, <span class="code">!EMPTY</span>, ...) </td></td></td></td></tr></table></div><br /><div align="right"><span class="less_significant">Verarbeitet in 0,1729 Sek. | Dateiformat: PC</span></div>      </div>
